<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/style/reset.css" />
    <link rel="stylesheet" href="/style/main.css" />
    <title>마법의 소라고동</title>
    <style></style>
  </head>
  <body>
    <main id="main-view">
      <section id="conch-render-section">
        <img src="/public/conch.webp" alt="conch" id="conch-img" />
        <canvas id="canvas" width="500px" height="600px"></canvas>
      </section>
      <section id="conch-answer-section">
        <p id="answer"></p>
        <input id="input" type="text" placeholder="마법의 소라고동님께 질문하라" />
      </section>
    </main>

    <script>
      const canvas = document.querySelector("#canvas");
      const ctx = canvas.getContext("2d");

      const $input = document.querySelector("#input");
      const $answer = document.querySelector("#answer");

      const answers = [
        "아무것도 하지 마.",
        "안 돼.",
        "언젠가는.",
        "다시 시도해 봐.",
        "그러지 마.",
        "좋은 생각이야!",
        "별로야.",
        "전혀 몰라.",
        "아마도.",
        "절대 안 돼.",
        "그건 알 수 없어.",
        "할 수 있어!",
        "포기해.",
        "운명에 맡겨.",
        "조용히 해.",
        "그럼!",
        "기다려 봐.",
        "말도 안 돼.",
        "넌 아직 준비가 안 됐어.",
        "그건 비밀이야.",
      ];

      let isDragging = false;
      let hasDragged = false;
      let isDisabled = false;

      const INIT_X = 340;
      const INIT_Y = 340;

      let mouseX = INIT_X;
      let mouseY = INIT_Y;

      const initPosition = { x: INIT_X, y: INIT_Y };
      const maxLength = 200;
      const returnSpeed = 0.05;

      const outerRadius = 20;
      const innerRadius = 5;

      function askRandomAnswer() {
        const randomAnswer = Math.floor(Math.random() * answers.length);
        return answers[randomAnswer];
      }

      function isInsideClick(x, y) {
        const validRadius = Math.sqrt((x - mouseX) ** 2 + (y - mouseY) ** 2);
        return validRadius >= innerRadius && validRadius <= outerRadius;
      }

      function drawLineAndCircle(x, y) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // drawLine
        ctx.strokeStyle = "lightgray";
        ctx.beginPath();
        ctx.moveTo(initPosition.x, initPosition.y);
        ctx.lineTo(x, y);
        ctx.stroke();

        // drawOuterCircle
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
        ctx.fillStyle = "lightgray";
        ctx.fill();
        ctx.strokeStyle = "gray";
        ctx.lineWidth = 2;
        ctx.stroke();

        // drawInnerCircle
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";

        ctx.beginPath();
        ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function setTimeoutPromise(ms) {
        return new Promise((resolve, reject) => {
          setTimeout(resolve, ms);
        });
      }

      function animate() {
        if (!isDragging) {
          mouseX += (initPosition.x - mouseX) * returnSpeed;
          mouseY += (initPosition.y - mouseY) * returnSpeed;
        }

        drawLineAndCircle(mouseX, mouseY);
        requestAnimationFrame(animate);
      }

      canvas.addEventListener("mousedown", (event) => {
        if (isDisabled) return;

        const rect = canvas.getBoundingClientRect();

        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        if (isInsideClick(clickX, clickY)) {
          isDragging = true;
          hasDragged = false;
        }
      });

      canvas.addEventListener("mousemove", (event) => {
        if (isDragging) {
          hasDragged = true;

          const rect = canvas.getBoundingClientRect();

          let clickX = event.clientX - rect.left;
          let clickY = event.clientY - rect.top;

          const distanceX = clickX - initPosition.x;
          const distanceY = clickY - initPosition.y;

          const currentDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (currentDistance > maxLength) {
            const angle = Math.atan2(distanceY, distanceX);

            clickX = initPosition.x + maxLength * Math.cos(angle);
            clickY = initPosition.y + maxLength * Math.sin(angle);
          }

          mouseX = clickX;
          mouseY = clickY;
        }
      });

      canvas.addEventListener("mouseup", async () => {
        if (isDragging && hasDragged) {
          isDragging = false;
          hasDragged = false;
          isDisabled = true;

          let blinkCount = 0;

          $input.classList.add("disabled");
          $input.disabled = true;

          $answer.style.opacity = "1";
          $answer.textContent = "";

          const blinkInterval = setInterval(() => {
            $answer.textContent = blinkCount % 2 === 0 ? "" : "...";
            blinkCount++;
          }, 500);

          await setTimeoutPromise(3500);
          clearInterval(blinkInterval);

          await setTimeoutPromise(1000);

          if ($input.value.trim() === "") {
            $answer.textContent = "질문을 해";
          } else {
            $answer.textContent = askRandomAnswer();
          }

          $answer.style.opacity = "1";

          await setTimeoutPromise(1500);
          $input.value = "";
          $input.classList.remove("disabled");
          $input.disabled = false;

          isDisabled = false;
        }
      });

      animate();
    </script>
  </body>
</html>
