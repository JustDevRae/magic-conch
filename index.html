<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>마법의 소라고동</title>
    <style>
      body {
        overflow: hidden;
        margin: 0;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      canvas {
        border: 1px solid black;
      }

      input {
        position: absolute;
        z-index: 1;
        bottom: 150px;
        left: 50%;
        transform: translateX(-50%);
        width: 250px;
        height: 30px;
        border-radius: 999px;
        padding: 5px 15px;
        transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
      }

      input.disabled {
        transform: translateX(-50%) translateY(70vh);
        opacity: 0;
      }

      #answer {
        position: absolute;
        top: 500px;
        font-size: 24px;
        font-weight: bold;
        color: black;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="500" height="600"></canvas>

    <input type="text" id="input" />
    <div id="answer">아니오</div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const $input = document.getElementById("input");
      const $answer = document.getElementById("answer");

      let isDragging = false;
      let hasDragged = false;

      let mouseX = 250;
      let mouseY = 200;

      const initPosition = { x: 250, y: 200 };
      const maxLength = 200;
      const returnSpeed = 0.05;

      const outerRadius = 20;
      const innerRadius = 5;

      function isInsideClick(x, y) {
        const validRadius = Math.sqrt((x - mouseX) ** 2 + (y - mouseY) ** 2);
        return validRadius >= innerRadius && validRadius <= outerRadius;
      }

      // 사용자가 해당 element에서 마우스 버튼을 눌렀을 때 발생
      canvas.addEventListener("mousedown", (event) => {
        const rect = canvas.getBoundingClientRect();

        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        if (isInsideClick(clickX, clickY)) {
          isDragging = true;
          hasDragged = false;
        }
      });

      // 사용자가 해당 element에서 마우스를 움직였을 때 발생
      canvas.addEventListener("mousemove", (event) => {
        if (isDragging) {
          hasDragged = true;

          const rect = canvas.getBoundingClientRect();

          let clickX = event.clientX - rect.left;
          let clickY = event.clientY - rect.top;

          const distanceX = clickX - initPosition.x;
          const distanceY = clickY - initPosition.y;

          const currentDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (currentDistance > maxLength) {
            const angle = Math.atan2(distanceY, distanceX);

            clickX = initPosition.x + maxLength * Math.cos(angle);
            clickY = initPosition.y + maxLength * Math.sin(angle);
          }

          mouseX = clickX;
          mouseY = clickY;
        }
      });

      // 사용자가 해당 element에서 눌렀던 마우스 버튼을 떼었을 때 발생
      canvas.addEventListener("mouseup", () => {
        if (isDragging && hasDragged) {
          // 드래그한 경우에만 input 이동
          $input.classList.add("disabled");
          $input.disabled = true;

          // 2초 동안 "..." 텍스트 깜박이기
          let blinkCount = 0;
          $answer.style.opacity = "1"; // 텍스트 보이게 설정
          $answer.textContent = "...";
          const blinkInterval = setInterval(() => {
            $answer.textContent = blinkCount % 2 === 0 ? "" : "...";
            blinkCount++;
          }, 300);

          // 2초 후 랜덤으로 "네" 또는 "아니오" 표시 (처음엔 숨김)
          setTimeout(() => {
            clearInterval(blinkInterval); // 깜박이기 중지
            $answer.textContent = Math.random() > 0.5 ? "네" : "아니오";
            $answer.style.opacity = "1"; // 2초 후에만 보이게 설정

            // 2초 후 input 원래 위치로 복귀
            $input.classList.remove("disabled");
            $input.disabled = false;
          }, 2000);
        }

        isDragging = false;
      });

      function drawLine(x, y) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.beginPath();
        ctx.moveTo(initPosition.x, initPosition.y);
        ctx.lineTo(x, y);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
        ctx.fillStyle = "red";
        ctx.fill();

        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";
      }

      function animate() {
        if (!isDragging) {
          mouseX += (initPosition.x - mouseX) * returnSpeed;
          mouseY += (initPosition.y - mouseY) * returnSpeed;
        }
        drawLine(mouseX, mouseY);
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
