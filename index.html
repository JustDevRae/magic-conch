<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>마법의 소라고동</title>
    <style>
      body {
        overflow: hidden;
        margin: 0 auto;
        height: 100vh;
        display: flex;
        align-items: center;
      }

      #box {
        width: 500px;
        height: 600px;
        position: relative;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      #canvas {
        border: 1px solid black;
      }

      #input {
        position: absolute;
        z-index: 1;
        bottom: 25%;
        left: 50%;
        transform: translateX(-50%);
        width: 250px;
        height: 30px;
        border-radius: 999px;
        padding: 5px 15px;
        transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
      }

      #input.disabled {
        transform: translateX(-50%) translateY(70vh);
        opacity: 0;
      }

      #answer {
        position: absolute;
        bottom: 50%;
        font-size: 24px;
        font-weight: bold;
        color: black;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div id="box">
      <canvas id="canvas" width="500" height="600"></canvas>
      <input type="text" id="input" placeholder="마법의 소라고동님께 질문하라" />
      <div id="answer">아니오</div>
    </div>

    <script>
      const canvas = document.querySelector("#canvas");
      const ctx = canvas.getContext("2d");

      const $input = document.querySelector("#input");
      const $answer = document.querySelector("#answer");

      const answers = [
        "아무것도 하지 마.",
        "안 돼.",
        "언젠가는.",
        "다시 시도해 봐.",
        "그러지 마.",
        "좋은 생각이야!",
        "별로야.",
        "전혀 몰라.",
        "아마도.",
        "절대 안 돼.",
        "그건 알 수 없어.",
        "할 수 있어!",
        "포기해.",
        "운명에 맡겨.",
        "조용히 해.",
        "그럼!",
        "기다려 봐.",
        "말도 안 돼.",
        "넌 아직 준비가 안 됐어.",
        "그건 비밀이야.",
      ];

      let isDragging = false;
      let hasDragged = false;

      let mouseX = 250;
      let mouseY = 200;

      const initPosition = { x: 250, y: 200 };
      const maxLength = 200;
      const returnSpeed = 0.05;

      const outerRadius = 20;
      const innerRadius = 5;

      function askRandomAnswer() {
        const randomAnswer = Math.floor(Math.random() * answers.length);
        return answers[randomAnswer];
      }

      function isInsideClick(x, y) {
        const validRadius = Math.sqrt((x - mouseX) ** 2 + (y - mouseY) ** 2);
        return validRadius >= innerRadius && validRadius <= outerRadius;
      }

      function drawLineAndCircle(x, y) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // drawLine
        ctx.beginPath();
        ctx.moveTo(initPosition.x, initPosition.y);
        ctx.lineTo(x, y);
        ctx.stroke();

        // drawOuterCircle
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
        ctx.fillStyle = "red";
        ctx.fill();

        // drawInnerCircle
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";
      }

      function setTimeoutPromise(ms) {
        return new Promise((resolve, reject) => {
          setTimeout(resolve, ms);
        });
      }

      function animate() {
        if (!isDragging) {
          mouseX += (initPosition.x - mouseX) * returnSpeed;
          mouseY += (initPosition.y - mouseY) * returnSpeed;
        }

        drawLineAndCircle(mouseX, mouseY);
        requestAnimationFrame(animate);
      }

      canvas.addEventListener("mousedown", (event) => {
        const rect = canvas.getBoundingClientRect();

        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        if (isInsideClick(clickX, clickY)) {
          isDragging = true;
          hasDragged = false;
        } else {
          isDragging = false;
          hasDragged = false;
        }
      });

      canvas.addEventListener("mousemove", (event) => {
        if (isDragging) {
          hasDragged = true;

          const rect = canvas.getBoundingClientRect();

          let clickX = event.clientX - rect.left;
          let clickY = event.clientY - rect.top;

          const distanceX = clickX - initPosition.x;
          const distanceY = clickY - initPosition.y;

          const currentDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (currentDistance > maxLength) {
            const angle = Math.atan2(distanceY, distanceX);

            clickX = initPosition.x + maxLength * Math.cos(angle);
            clickY = initPosition.y + maxLength * Math.sin(angle);
          }

          mouseX = clickX;
          mouseY = clickY;
        }
      });

      canvas.addEventListener("mouseup", async () => {
        if (isDragging && hasDragged) {
          isDragging = false;
          hasDragged = false;

          let blinkCount = 0;

          $input.classList.add("disabled");
          $input.disabled = true;

          $answer.style.opacity = "1";
          $answer.textContent = "";

          const blinkInterval = setInterval(() => {
            $answer.textContent = blinkCount % 2 === 0 ? "" : "...";
            blinkCount++;
          }, 500);

          await setTimeoutPromise(3500);
          clearInterval(blinkInterval);

          await setTimeoutPromise(1000);
          // TODO: 무작위 답변 내놓기 기능 추가 예정

          if ($input.value.trim() === "") {
            $answer.textContent = "질문을 해";
          } else {
            $answer.textContent = askRandomAnswer();
          }

          $answer.style.opacity = "1";

          await setTimeoutPromise(1500);
          $input.value = "";
          $input.classList.remove("disabled");
          $input.disabled = false;
        }
      });

      animate();
    </script>
  </body>
</html>
